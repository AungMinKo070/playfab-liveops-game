{
    "Version": 1,
    "Revision": 7,
    "CreatedAt": "2019-07-27T06:37:12.97Z",
    "Files": [
        {
            "Filename": "main.js",
            "FileContents": "\"use strict\";\nconst App = {\n    IsNull(data) {\n        return typeof data === \"undefined\"\n            || data === null\n            || (typeof data === \"string\" && data.length === 0)\n            || (data.constructor === Array && data.length === 0);\n    },\n    GetTitleData(keys, isJSON) {\n        const data = server.GetTitleData({\n            Keys: keys\n        }).Data;\n        if (!isJSON) {\n            return data;\n        }\n        return Object.keys(data).reduce((dictionary, key) => {\n            dictionary[key] = JSON.parse(data[key]);\n            return dictionary;\n        }, {});\n    },\n    EvaluateRandomResultTable(catalogVersion, tableId) {\n        return server.EvaluateRandomResultTable({\n            CatalogVersion: catalogVersion,\n            TableId: tableId\n        }).ResultItemId;\n    },\n    GetPlayerStatistics(playerId, statisticNames) {\n        return server.GetPlayerStatistics({\n            PlayFabId: playerId,\n            StatisticNames: statisticNames,\n        }).Statistics;\n    },\n    UpdatePlayerStatistics(playerId, statistics) {\n        return server.UpdatePlayerStatistics({\n            PlayFabId: playerId,\n            Statistics: statistics,\n        });\n    },\n    ConsumeItem(playerId, itemInstanceId, count) {\n        return server.ConsumeItem({\n            PlayFabId: playerId,\n            ItemInstanceId: itemInstanceId,\n            ConsumeCount: count\n        });\n    },\n    GrantItemsToUser(playerId, itemIds, catalogVersion = null) {\n        const grantResult = server.GrantItemsToUser({\n            PlayFabId: playerId,\n            ItemIds: itemIds,\n            CatalogVersion: catalogVersion\n        });\n        // Is this a bundle of something we need to unpack?\n        grantResult.ItemGrantResults.forEach(item => {\n            if (item.ItemClass.indexOf(App.CatalogItems.UnpackClassName) !== -1) {\n                App.ConsumeItem(playerId, item.ItemInstanceId, item.RemainingUses);\n            }\n        });\n    },\n    GetUserInventory(playerId) {\n        return server.GetUserInventory({\n            PlayFabId: playerId,\n        });\n    },\n    GetUserData(playerId, keys) {\n        return server.GetUserData({\n            PlayFabId: playerId,\n            Keys: keys,\n        });\n    },\n    UpdateUserData(playerId, data, keysToRemove, isPublic = false) {\n        return server.UpdateUserData({\n            PlayFabId: playerId,\n            Data: data,\n            KeysToRemove: keysToRemove,\n            Permission: isPublic\n                ? App.Config.PermissionPublic\n                : App.Config.PermissionPrivate\n        });\n    },\n    UpdateUserDataExisting(dictionary, isPublic) {\n        const userData = App.GetUserData(currentPlayerId, Object.keys(dictionary));\n        Object.keys(dictionary).forEach(key => {\n            userData.Data[key] = {\n                Value: dictionary[key],\n                LastUpdated: new Date().toString(),\n                Permission: isPublic\n                    ? App.Config.PermissionPublic\n                    : App.Config.PermissionPrivate\n            };\n        });\n        // Turn this UserDataRecordDictionary into a plain IStringDictionary\n        const userDataStringDictionary = Object.keys(userData.Data).reduce((dictionary, key) => {\n            dictionary[key] = userData.Data[key].Value;\n            return dictionary;\n        }, {});\n        return App.UpdateUserData(currentPlayerId, userDataStringDictionary, null, true);\n    },\n    WritePlayerEvent(playerId, eventName, body) {\n        server.WritePlayerEvent({\n            PlayFabId: playerId,\n            EventName: eventName,\n            Body: body,\n        });\n    },\n    Statistics: {\n        Kills: \"kills\",\n        HP: \"hp\"\n    },\n    TitleData: {\n        Planets: \"Planets\",\n        Enemies: \"Enemies\",\n    },\n    UserData: {\n        HP: \"hp\",\n        MaxHP: \"maxHP\",\n        Equipment: \"equipment\"\n    },\n    CatalogItems: {\n        StartingPack: \"StartingPack\",\n        UnpackClassName: \"unpack\",\n    },\n    VirtualCurrency: {\n        Credits: \"CR\"\n    },\n    Config: {\n        StartingHP: 100,\n        PermissionPublic: \"Public\",\n        PermissionPrivate: \"Private\"\n    }\n};\nhandlers.killedEnemyGroup = function (args, context) {\n    const planetsAndEnemies = App.GetTitleData([App.TitleData.Planets, App.TitleData.Enemies], true);\n    const planetData = planetsAndEnemies[App.TitleData.Planets].planets;\n    const enemyData = planetsAndEnemies[App.TitleData.Enemies];\n    // Ensure the data submitted is valid\n    const errorMessage = isKilledEnemyGroupValid(args, planetData, enemyData);\n    if (!App.IsNull(errorMessage)) {\n        return {\n            errorMessage,\n        };\n    }\n    // Data is valid, continue\n    const fullEnemyGroup = enemyData.enemyGroups.find(e => e.name === args.enemyGroup);\n    // Update player statistics\n    const statistics = App.GetPlayerStatistics(currentPlayerId, [App.Statistics.Kills]);\n    const statisticUpdates = [];\n    if (!App.IsNull(statistics)) {\n        const killStatistic = statistics.find(s => s.StatisticName === App.Statistics.Kills);\n        const startingKills = App.IsNull(killStatistic)\n            ? 0\n            : killStatistic.Value;\n        statisticUpdates.push({\n            StatisticName: App.Statistics.Kills,\n            Value: startingKills + fullEnemyGroup.enemies.length,\n        });\n        App.UpdatePlayerStatistics(currentPlayerId, statisticUpdates);\n    }\n    // Also update your HP, which is stored in user data\n    App.UpdateUserDataExisting({\n        [App.UserData.HP]: args.playerHP.toString()\n    }, true);\n    // Grant items\n    let itemGranted = null;\n    if (!App.IsNull(fullEnemyGroup.droptable)) {\n        itemGranted = App.EvaluateRandomResultTable(null, fullEnemyGroup.droptable);\n        App.GrantItemsToUser(currentPlayerId, [itemGranted]);\n    }\n    return {\n        itemGranted\n    };\n};\nhandlers.playerLogin = function (args, context) {\n    // If you're a new player with no money nor items, give you some cash and set your HP\n    const response = {\n        didGrantStartingPack: false,\n        playerHP: 0,\n        equipment: {},\n    };\n    // Give new players their starting items\n    const inventory = App.GetUserInventory(currentPlayerId);\n    if (App.IsNull(inventory.Inventory) && inventory.VirtualCurrency[App.VirtualCurrency.Credits] === 0) {\n        response.didGrantStartingPack = true;\n        App.GrantItemsToUser(currentPlayerId, [App.CatalogItems.StartingPack]);\n    }\n    // Give new players some HP using title data\n    const userData = App.GetUserData(currentPlayerId, [App.UserData.HP, App.UserData.Equipment]);\n    if (App.IsNull(userData.Data[App.UserData.HP])) {\n        App.UpdateUserDataExisting({\n            [App.UserData.HP]: App.Config.StartingHP.toString(),\n            [App.UserData.MaxHP]: App.Config.StartingHP.toString(),\n        }, true);\n        response.playerHP = App.Config.StartingHP;\n    }\n    else {\n        response.playerHP = parseInt(userData.Data[App.UserData.HP].Value);\n    }\n    if (!App.IsNull(userData.Data[App.UserData.Equipment])) {\n        response.equipment = JSON.parse(userData.Data[App.UserData.Equipment].Value);\n    }\n    return response;\n};\nhandlers.returnToHomeBase = function (args, context) {\n    const hpAndMaxHP = App.GetUserData(currentPlayerId, [App.UserData.HP, App.UserData.MaxHP]);\n    const maxHP = parseInt(hpAndMaxHP.Data[App.UserData.MaxHP].Value);\n    if (hpAndMaxHP.Data[App.UserData.HP].Value === hpAndMaxHP.Data[App.UserData.MaxHP].Value) {\n        App.WritePlayerEvent(currentPlayerId, \"travel_to_home_base\", null);\n        return {\n            maxHP\n        };\n    }\n    App.UpdateUserData(currentPlayerId, {\n        [App.UserData.HP]: hpAndMaxHP.Data[App.UserData.MaxHP].Value,\n    }, null, true);\n    App.WritePlayerEvent(currentPlayerId, \"travel_to_home_base_restore_hp\", null);\n    return {\n        maxHP\n    };\n};\nhandlers.equipItem = function (args, context) {\n    const currentEquipment = App.GetUserData(currentPlayerId, [App.UserData.Equipment]).Data;\n    let returnResult = null;\n    const equipmentDictionary = App.IsNull(args.multiple)\n        ? { [args.single.slot]: args.single.itemInstanceId }\n        : args.multiple.reduce((dictionary, request) => {\n            dictionary[request.slot] = request.itemInstanceId;\n            return dictionary;\n        }, {});\n    if (App.IsNull(currentEquipment[App.UserData.Equipment])) {\n        returnResult = App.UpdateUserData(currentPlayerId, {\n            [App.UserData.Equipment]: JSON.stringify(equipmentDictionary)\n        }, null, true);\n    }\n    else {\n        returnResult = App.UpdateUserData(currentPlayerId, {\n            [App.UserData.Equipment]: JSON.stringify(Object.assign({}, JSON.parse(currentEquipment[App.UserData.Equipment].Value), equipmentDictionary))\n        }, null, true);\n    }\n    App.WritePlayerEvent(currentPlayerId, \"equipped_item\", args);\n    return returnResult;\n};\n// ----- Helpers ----- //\nconst isKilledEnemyGroupValid = function (args, planetData, enemyData) {\n    const planet = planetData.find(p => p.name === args.planet);\n    if (planet === undefined) {\n        return `Planet ${args.planet} not found.`;\n    }\n    const area = planet.areas.find(a => a.name === args.area);\n    if (area === undefined) {\n        return `Area ${args.area} not found on planet ${args.planet}.`;\n    }\n    const enemyGroup = area.enemyGroups.find(e => e === args.enemyGroup);\n    if (enemyGroup === undefined) {\n        return `Enemy group ${args.enemyGroup} not found in area ${args.area} on planet ${args.planet}.`;\n    }\n    const fullEnemyGroup = enemyData.enemyGroups.find(e => e.name === args.enemyGroup);\n    if (fullEnemyGroup === undefined) {\n        return `Enemy group ${args.enemyGroup} not found.`;\n    }\n    return undefined;\n};\n"
        }
    ],
    "IsPublished": true
}
{
    "Version": 1,
    "Revision": 4,
    "CreatedAt": "2019-07-26T20:26:07.139Z",
    "Files": [
        {
            "Filename": "main.js",
            "FileContents": "\"use strict\";\nconst App = {\n    IsNull(data) {\n        return typeof data === \"undefined\"\n            || data === null\n            || (typeof data === \"string\" && data.length === 0)\n            || (data.constructor === Array && data.length === 0);\n    },\n    GetTitleData(keys) {\n        return server.GetTitleData({\n            Keys: keys\n        }).Data;\n    },\n    EvaluateRandomResultTable(catalogVersion, tableId) {\n        return server.EvaluateRandomResultTable({\n            CatalogVersion: catalogVersion,\n            TableId: tableId\n        }).ResultItemId;\n    },\n    GetPlayerStatistics(statisticNames) {\n        return server.GetPlayerStatistics({\n            StatisticNames: statisticNames,\n        }).Statistics;\n    },\n    UpdatePlayerStatistics(playerId, statistics) {\n        return server.UpdatePlayerStatistics({\n            PlayFabId: playerId,\n            Statistics: statistics,\n        });\n    },\n    ConsumeItem(playerId, itemInstanceId, count) {\n        return server.ConsumeItem({\n            PlayFabId: playerId,\n            ItemInstanceId: itemInstanceId,\n            ConsumeCount: count\n        });\n    },\n    GrantItemsToUser(playerId, itemIds, catalogVersion = null) {\n        const grantResult = server.GrantItemsToUser({\n            PlayFabId: playerId,\n            ItemIds: itemIds,\n            CatalogVersion: catalogVersion\n        });\n        // Is this a bundle of credits we need to unpack?\n        grantResult.ItemGrantResults.forEach(item => {\n            if (item.ItemClass.indexOf(App.Config.UnpackClassName) !== -1) {\n                App.ConsumeItem(playerId, item.ItemInstanceId, item.RemainingUses);\n            }\n        });\n    },\n    GetUserInventory(playerId) {\n        return server.GetUserInventory({\n            PlayFabId: playerId,\n        });\n    },\n    Config: {\n        UnpackClassName: \"unpack\",\n    },\n    Statistics: {\n        Kills: \"kills\",\n        HP: \"hp\"\n    },\n    TitleData: {\n        Planets: \"Planets\",\n        Enemies: \"Enemies\"\n    },\n    CatalogItems: {\n        StartingPack: \"StartingPack\",\n    }\n};\nconst isKilledEnemyGroupValid = function (args, planetData, enemyData) {\n    const planet = planetData.find(p => p.name === args.planet);\n    if (planet === undefined) {\n        return `Planet ${args.planet} not found.`;\n    }\n    const area = planet.areas.find(a => a.name === args.area);\n    if (area === undefined) {\n        return `Area ${args.area} not found on planet ${args.planet}.`;\n    }\n    const enemyGroup = area.enemyGroups.find(e => e === args.enemyGroup);\n    if (enemyGroup === undefined) {\n        return `Enemy group ${args.enemyGroup} not found in area ${args.area} on planet ${args.planet}.`;\n    }\n    const fullEnemyGroup = enemyData.enemyGroups.find(e => e.name === args.enemyGroup);\n    if (fullEnemyGroup === undefined) {\n        return `Enemy group ${args.enemyGroup} not found.`;\n    }\n    return undefined;\n};\nhandlers.killedEnemyGroup = function (args, context) {\n    const planetsAndEnemies = App.GetTitleData([App.TitleData.Planets, App.TitleData.Enemies]);\n    const planetData = planetsAndEnemies.Planets.planets;\n    const enemyData = planetsAndEnemies.Enemies;\n    // Ensure the data submitted is valid\n    const errorMessage = isKilledEnemyGroupValid(args, planetData, enemyData);\n    if (!App.IsNull(errorMessage)) {\n        return {\n            isError: true,\n            errorMessage,\n        };\n    }\n    // Data is valid, continue\n    const fullEnemyGroup = enemyData.enemyGroups.find(e => e.name === args.enemyGroup);\n    // Update player statistics\n    const statistics = App.GetPlayerStatistics([App.Statistics.Kills, App.Statistics.HP]);\n    const statisticUpdates = [];\n    if (!App.IsNull(statistics)) {\n        const killStatistic = statistics.find(s => s.StatisticName === App.Statistics.Kills);\n        const hpStatistic = statistics.find(s => s.StatisticName === App.Statistics.HP);\n        if (!App.IsNull(killStatistic)) {\n            statisticUpdates.push({\n                StatisticName: App.Statistics.Kills,\n                Value: killStatistic.Value + fullEnemyGroup.enemies.length,\n            });\n        }\n        if (!App.IsNull(hpStatistic)) {\n            // Can't go below zero health\n            statisticUpdates.push({\n                StatisticName: App.Statistics.HP,\n                Value: Math.max(0, hpStatistic.Value - args.damageTaken),\n            });\n        }\n    }\n    if (statisticUpdates.length !== 0) {\n        App.UpdatePlayerStatistics(currentPlayerId, statisticUpdates);\n    }\n    // Grant items if they're lucky\n    let itemGranted = null;\n    if (fullEnemyGroup.droptable && fullEnemyGroup.dropchance && Math.random() <= fullEnemyGroup.dropchance) {\n        itemGranted = App.EvaluateRandomResultTable(undefined, fullEnemyGroup.droptable);\n        App.GrantItemsToUser(currentPlayerId, [itemGranted]);\n    }\n    return {\n        isError: false,\n        itemGranted\n    };\n};\nhandlers.playerLogin = function (args, context) {\n    // If you're a new player with no money nor items, give you some cash\n    // Make sure you have no money and no items\n    const inventory = App.GetUserInventory(currentPlayerId);\n    if (!App.IsNull(inventory.Inventory) || !App.IsNull(inventory.VirtualCurrency)) {\n        return;\n    }\n    App.GrantItemsToUser(currentPlayerId, [App.CatalogItems.StartingPack]);\n};\n"
        }
    ],
    "IsPublished": true
}